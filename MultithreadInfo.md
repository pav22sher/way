##Многопоточность

> Многопоточность в Java — это одновременное выполнение двух или более потоков
> для максимального использования центрального процессора (CPU — central processing unit).

Для чего используют многопоточность:
* Ускорить вычисления, чтобы сделать что-то быстрее.
* Одновременно выполнять несколько действий, 
  чтобы пользователь мог дальше работать с приложением, 
  а не ждать завершения каких-то действий.

###Взаимная блокировка (deadlock)

> Взаимная блокировка (deadlock) - ситуация, при которой несколько потоков находятся в состоянии
> ожидания ресурсов, занятых друг другом, и ни один из них не может продолжать выполнение.

Пример:
```
«В некоторых штатах Индии вам не продадут землю сельскохозяйственного назначения,
если вы не зарегистрированы как фермер. При этом вас не зарегистрируют в качестве фермера,
если вы не владеете сельскохозяйственными землями».
```

###Состояние гонки (race condition)

> Состояние гонки (race condition) - ошибка проектирования многопоточной системы или приложения,
> при которой работа системы или приложения зависит от того, в каком порядке выполняются части кода.

> Состояние гонки возникает, когда один и тот же ресурс используется несколькими потоками одновременно,
> и в зависимости от порядка действий каждого потока может быть несколько возможных результатов.

> Гонка данных (data race) - возникает, когда два или более потока пытаются получить доступ
> к одной и той же не финальной переменной без синхронизации.

###Синхронизация

> Синхронизация – это процесс, который позволяет выполнять 
> все параллельные потоки в программе синхронно

> Отсутствие синхронизации может привести к внесению изменений,
> которые не будут видны другим потокам, из-за этого возможно чтение устаревших данных,
> что, в свою очередь, приводит к бесконечным циклам,
> поврежденным структурам данных или неточным вычислениям. 

> Synchronized ключевое слово помечает блок или метод как критический раздел.
> Критическая секция – это то, где одновременно выполняется только один поток.

> Синхронизированный блок:
> synchronized (lockObject){//synchronized code}

> Синхронизированный метод:
> synchronized method (parameters){//synchronized code}

В случае синхронизированного метода объект блокировки:
* Если метод статический, то объект класса Class.
* Если метод нестатический, то объект this.

###Монитор(Мьютекс)

> Мьютекс (mutual exclusion — «взаимное исключение») — примитив синхронизации,
> обеспечивающий взаимное исключение исполнения
> критических участков кода несколькими потоками.

> Каждый объект в Java имеет ассоциированный с ним монитор.
> Монитор представляет своего рода инструмент для управления доступа к объекту.

> Когда выполнение кода доходит до оператора synchronized,
> монитор объекта блокируется, и на время его блокировки
> монопольный доступ к блоку кода имеет только один поток,
> который и произвел блокировку. После окончания работы блока кода,
> монитор объекта освобождается и становится доступным для других потоков.

###Процесс

> Процесс — экземпляр программы во время выполнения, независимый объект,
> которому выделены системные ресурсы (например, процессорное время и память),
> процесс состоит из потоков.

> Каждый процесс выполняется в отдельном адресном пространстве:
> один процесс не может получить доступ к переменным и структурам данных другого.

> PID - идентификатор процесса.

###Поток

> Поток — определенный способ выполнения процесса, 
> их также часто называют легковесными процессами,
> потоки могут выполняться параллельно друг с другом.

> Потоки используют адресное пространство процесса и делят его с другими потоками.
> Когда один поток изменяет ресурс процесса,
> это изменение сразу же становится видно другим потокам этого процесса.

> TID - идентификатор потока.

###Создание потоков

```java
public class FirstThread extends Thread {
   @Override
   public void run() {
       System.out.println("Выполнен поток " + getName());
   }
}
class SecondThread implements Runnable {
  public void run(){
    System.out.println("Выполнен поток " + Thread.currentThread().getName());
  }
}
public class Main {
   public static void main(String[] args) {
     FirstThread firstThread = new MyFirstThread();
     thread.start();
     Thread secondThread = new Thread(new SecondThread());
     myThread.start();
   }
}
```

###Поток-демон

> Поток-демон - поток, работающий в фоновом режиме для нашей программы.

> Маленькие программы обычно состоят из одной нити, называемой «главной нитью» (main thread). 
> Даже если метод main() уже завершился, но еще выполняются порожденные им потоки,
> система будет ждать их завершения.

> Если завершился последний обычный поток процесса, и остались только потоки-демоны,
> то они будут принудительно завершены и выполнение процесса закончится.

> Объявить поток демоном достаточно просто — нужно перед запуском потока вызвать его метод setDaemon(true);
> Проверить, является ли поток демоном, можно вызвав его метод boolean isDaemon();

###ThreadGroup

> ThreadGroup представляет собой набор нитей,
> которые так же могут содержать в себе другие группы потоков.

> Основное преимущество группы потоков заключается в том,
> что мы можем выполнять такие операции, как приостановка,
> возобновление или прерывание для всех потоков, используя один вызов функции.

###Состояния потока

Состояния потока:
* NEW - Поток, который еще не запущен, находится в этом состоянии.
* RUNNABLE - Поток, выполняющийся JVM, находится в этом состоянии.
* BLOCKED - Поток, заблокированный и ожидающий блокировки монитора, 
  находится в этом состоянии.
* WAITING - Поток, который ждет, пока другой поток выполнит определенное 
  действие, находится в этом состоянии.
* TIMED_WAITING - Поток, который ожидает, пока другой поток выполнит 
  действие в течение указанного времени ожидания, находится в этом состоянии.
* TERMINATED - Завершившийся поток находится в этом состоянии.

###Приоритеты потоков

> Каждый поток Java имеет приоритет, который помогает ОС определить порядок выполнения потока.
> Потоки с более высоким приоритетом более важны для программы, 
> и в первую очередь им должно выделяться процессорное время.

> Приоритеты потоков Java находятся в диапазоне от 1 до 10. 
> По умолчанию каждому потоку устанавливается приоритет 5.

Константы приоритетов:
* MIN_PRIORITY(константа 1)
* NORM_PRIORITY (константа 5)
* MAX_PRIORITY (константа 10)

###Не статические методы класса Thread

Не статические методы класса Thread:
* long getId() - возвращает идентификатор потока
* State getState() - возвращает состояние потока
* ThreadGroup getThreadGroup() - возвращает группу потоков
* void setName(String name) - устанавливает имя потока
* void setPriority(int priority) - устанавливает приоритет потока
* void setDaemon(boolean on) - true - поток-демон
* void start() - запускает поток и вызывает метод run
* void run() - для объекта Runnable вызывается метод run()
* boolean isAlive() - проверяет жив ли поток
* void interrupt() - попытка прерывать поток
* boolean isInterrupted() - проверка был ли поток прерван
* void join() - текущий поток блокируется до тех пор, пока второй поток не завершится
* void join(long milliseconds) - текущий поток блокируется до тех пор, 
  пока второй поток не пройдет заданное количество миллисекунд
* void join(long milliseconds, int nanoseconds) - текущий поток блокируется до тех пор,
  пока второй поток не пройдет заданное количество миллисекунд и наносекунд

###Статические методы класса Thread

Статические методы класса Thread:
* void yield() - заставляет текущий запущенный поток уступить место другим потокам
* void sleep(long milliseconds) - блокирует текущий запущенный поток 
  на указанное количество миллисекунд
* void sleep(long milliseconds, int nanoseconds) - блокирует текущий запущенный поток 
  на указанное количество миллисекунд и наносекунд
* Thread currentThread() - возвращает ссылку на текущий поток
* boolean holdsLock(Object x) - возвращает true, если текущий поток удерживает 
  блокировку данного объекта.
* int activeCount() - возвращает кол-во активных потоков в группе
* int enumerate(Thread threadArray[]) - копирует все активные потоки группы в массив

##Concurrency API

###Пакет java.util.concurrent

Пакет java.util.concurrent состоит из:
* Atomics — классы с поддержкой атомарных операций над примитивами и ссылками.
* Locks — представляет собой альтернативные и более гибкие механизмы синхронизации потоков.
* Synchronizers — вспомогательные утилиты для синхронизации потоков.
* Executors — вспомогательные утилиты для создания пулов потоков,
  планирования работы асинхронных задач с получением результатов.
* Concurrent Collections — набор коллекций, более эффективно работающие
  в многопоточной среде нежели стандартные коллекции из java.util пакета.
* Queues — неблокирующие и блокирующие очереди с поддержкой многопоточности.

###Atomics

Операция называется атомарной, если её можно безопасно выполнять при параллельных вычислениях
в нескольких потоках, не используя при этом ни блокировок, ни синхронизацию synchronized.
Atomics:
* AtomicBoolean, AtomicInteger, AtomicLong, AtomicIntegerArray, AtomicLongArray - 
  атомарные операции над примитивными типами данных
* AtomicReference - атомарные операции над объектом
* AtomicReferenceArray - атомарные операции над массивом объектов
* AtomicMarkableReference - атомарные операции над парой объект-boolean
* AtomicStampedReference - атомарные операции над парой объект-int
* AtomicIntegerFieldUpdater, AtomicLongFieldUpdater,AtomicReferenceFieldUpdater - 
  атомарные операции над полями объекта через рефлексию

###Locks

Locks:
* интерфейс Lock - предоставляет более гибкий подход синхронизации 
  нежели при использовании synchronized
* интерфейс Condition - описывает альтернативные методы 
  стандартным wait/notify/notifyAll.
* интерфейс ReadWriteLock - поддерживает пару связанных блокировок:
  одну для чтения и одну для записи
* класс LockSupport - содержит методы для парковки потоков(park и unpark) 
  вместо устаревших методов Thread.suspend() и Thread.resume().
  
Методы Lock:
* lock - получение блокировки
* unlock - освобождение блокировки
* tryLock - получение блокировки, если она свободна
* newCondition - возвращает новый объект класса Condition, 
  привязанный к этому экземпляру блокировки.

Методы Condition:
* await - переводит поток в состояние ожидания(аналог wait)
* signal - сигнализирует поток, у которого ранее был вызван метод await(), 
  о возможности продолжения работы(аналог notify)
* signalAll - сигнализирует все потоки, у которых ранее был вызван метод await(),
  о возможности продолжения работы(аналог notifyAll)
  
###Synchronizers

Synchronizers:
* Semaphore - ограничения кол-ва потоков, которые могут работать одновременно.
* CyclicBarrier - синхронизация заданного количества потоков в одной точке.
* Exchanger - обмен объектами между двумя потоками, синхронизация потоков при обмене.
* CountDownLatch - позволяет одному или нескольким потокам ожидать до тех пор, 
  пока не завершится определенное количество операций, выполняющих в других потоках.
* Phaser - улучшенная реализация барьера для синхронизации потоков, 
  которая совмещает в себе функционал CyclicBarrier и CountDownLatch
  
###Executors

> Интерфейс Callable - интерфейс для выполнения асинхронной операции 
> и возврата значения после ее выполнения.
> Объект класса, реализующего интерфейс Callable, исполняются другим потоком. 
> Callable использует Generic для определения типа возвращаемого объекта.

```java
@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
```

> Интерфейс Future - интерфейс для получения результатов работы асинхронной операции.

Методы Future:
* cancel - попытка отменить выполнение задачи
* isCancelled - была ли отменена задача
* isDone - завершилась ли задача
* get - ожидание завершения задачи и получение результата

> Интерфейс Executor - базовый интерфейс для классов, реализующих запуск Runnable задач.

```java
public interface Executor {
    void execute(Runnable command);
}
```

> Интерфейс ExecutorService - базовый интерфейс для классов, реализующих запуск Runnable или Callable задач.
> ExecutorService extends Executor.

Методы интерфейса ExecutorService:
* Future<?> submit(Runnable task) - запускает задачу и возвращает объект будущего результата
* Future<T> submit(Runnable task, T result) - запускает задачу и возвращает объект будущего результата
* Future<T> submit(Callable<T> task) - запускает задачу и возвращает объект будущего результата
* void shutdown() - завершение работы, при котором ранее отправленные задачи выполняются, 
  а новые задачи не запускаются
* List<Runnable> shutdownNow() - завершение работы, при котором ранее отправленные задачи не выполняются
  и новые задачи не запускаются(возвращает список задача ожидающих выполнение)
* boolean isShutdown() - возвращает true, если исполнитель сервиса остановлен
* boolean isTerminated() - возвращает true, если все задачи исполнителя сервиса завершены
* <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) -
  выполняет заданные задачи
* <T> T invokeAny(Collection<? extends Callable<T>> tasks) -
  выполняет заданные задачи

> Интерфейс ScheduledExecutorService - базовый интерфейс для планирования потоков исполнения.
> ScheduledExecutorService extends ExecutorService.

Методы интерфейса ScheduledExecutorService:
* ScheduledFuture<?> schedule(Runnable command, long delay, TimeUnit unit) -
  запускает задачу после заданной задержки
* <V> ScheduledFuture<V> schedule(Callable<V> callable,long delay, TimeUnit unit) -
  запускает задачу после заданной задержки
* ScheduledFuture<?> scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) -
  запускает задачу после заданной задержки, а после задача запускается с указанной периодичностью
* ScheduledFuture<?> scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit); 
  запускает задачу после заданной задержки, а после задача запускается с указанной периодичностью

> Пул потоков - это набор объектов Runnable и постоянно работающих потоков. 
> Коллекция объектов Runnable называется рабочей очередью. 
> Постоянно запущенные потоки проверяют рабочий запрос на наличие новой работы, 
> и если новая работа должна быть выполнена, то из рабочей очереди будет запущен объект Runnable.
> Таким образом потоки могут быть повторно использованы.

> Класс Executors - фабричные методы для классов 
> Executor, ExecutorService, ScheduledExecutorService, Callable и т.д.

* ExecutorService newSingleThreadExecutor - используется один рабочий поток, 
  работающий в неограниченной очереди.
* ExecutorService newFixedThreadPool - создает пул потоков, который повторно использует 
  фиксированное количество потоков, работающих в общей неограниченной очереди
* ExecutorService newCachedThreadPool - создает пул потоков, который создает новые потоки по мере необходимости, 
  но будет повторно использовать ранее созданные потоки, когда они будут доступны.
* ExecutorService newWorkStealingPool - создает пул потоков, крадущих работу,
  используя количество доступных процессоров в качестве целевого уровня параллелизма,
  внутри используется ForkJoinPool.
* ScheduledExecutorService newSingleThreadScheduledExecutor - используется один рабочий поток,
  который выполняет команды с заданной задержкой или выполняет их периодически.
* ScheduledExecutorService newScheduledThreadPool - создает пул потоков,
  которые выполняют команды с заданной задержкой или выполняют их периодически.

####Fork Join

> Дизайн ForkJoinPool основан на алгоритме “Разделяй и властвуй”:
> каждая задача разбивается на подзадачи по максимуму, 
> затем они выполняются параллельно, и как только все из них завершаются, 
> происходит объединение результатов.

> Модель fork-join - это метод, в котором мы разделяем каждую задачу (fork),
> а затем ждем объединения (join) всех получившихся подзадач и получаем результат.

> ForkJoinPool – это пул потоков, преимущество которого состоит в том, 
> что он работает на основе принципа "кража работы"(Work Stealing).
> Когда один из потоков ForkJoinPool заканчивает свою работу,
> он берёт из общей очереди работ новую задачу. 
> Это продолжается до тех пор, пока задачи не кончатся.

> ForkJoinPool не использует Callable или Runnable задачи.
> ForkJoinTask является базовым типом для задач, выполняемых внутри ForkJoinPool.

ForkJoinTask:
* RecursiveAction - для задач, которые ничего не возвращают в результате выполнения(аналог Runnable)
* RecursiveTask - для задач, которые возвращают что-то в результате выполнения(аналог Callable)

> У них обоих есть абстрактный метод compute (), в котором определена логика задачи.
> Метод fork - отправляет задачу в пул, но не запускает ее выполнение.
> Метод join - отправляет задачу на исполнение и ожидает ее завершение.

###Concurrent Collections

Concurrent Collections:
* ConcurrentHashMap - потокобезопасный аналог HashMap
* CopyOnWriteArrayList - потокобезопасный аналог ArrayList
* CopyOnWriteArraySet - потокобезопасная реализация Set(внутри используется CopyOnWriteArrayList)
* ConcurrentSkipListMap - потокобезопасный аналог TreeMap
* ConcurrentSkipListSet - потокобезопасная реализация Set(внутри используется ConcurrentSkipListMap)

###Queues

Потокобезопасные и неблокирующие очереди(Non-Blocking Queues):
* ConcurrentLinkedQueue - обычная очередь(потокобезопасная реализация интерфейса Queue)
* ConcurrentLinkedDeque - двунаправленная очередь(потокобезопасная реализация интерфейса Deque)

Потокобезопасные и блокирующие очереди(Blocking Queues):
* интерфейс BlockingQueue - обычная очередь 
  (классы реализующие интерфейс BlockingQueue:
  ArrayBlockingQueue, DelayQueue, LinkedBlockingQueue,
  PriorityBlockingQueue, SynchronousQueue,LinkedTransferQueue)
* BlockingDeque - двунаправленная очередь
  (классы реализующие интерфейс BlockingDeque:
  LinkedBlockingDeque)
