###Паттерны проектирования

> Паттерны/Шаблоны проектирования — это руководства по решению повторяющихся проблем.
> Это не классы, пакеты или библиотеки, которые можно было бы подключить к вашему приложению 
> и сидеть в ожидании чуда. Они скорее являются методиками, как решать определенные проблемы 
> в определенных ситуациях.

> Антипаттерн — это распространённый подход к решению класса часто встречающихся проблем, 
> являющийся неэффективным, рискованным или непродуктивным. 

Шаблоны бывают следующих трех видов:
* Порождающие - предоставляют механизмы инициализации, позволяя создавать объекты удобным способом
* Структурные - определяют отношения между классами и объектами, позволяя им работать совместно
* Поведенческие - используются для того, чтобы упростить взаимодействие между сущностями

###Порождающие

* Singleton (Одиночка) - ограничивает создание одного экземпляра класса, 
  обеспечивает доступ к его единственному объекту.
* Factory (Фабрика) - используется, когда у нас есть суперкласс с несколькими подклассами 
  и на основе ввода, нам нужно вернуть один из подкласса.
* Abstract Factory (Абстрактная фабрика) - используем супер фабрику для создания фабрики, 
  затем используем созданную фабрику для создания объектов.
* Builder (Строитель) - используется для создания сложного объекта с использованием простых объектов.
* Prototype (Прототип) - помогает создать дублированный объект с лучшей производительностью,
  вместо нового создается возвращаемый клон существующего объекта.

###Структурные

* Adapter (Адаптер) - это конвертер между двумя несовместимыми объектами. 
  Используя паттерн адаптера, мы можем объединить два несовместимых интерфейса.
* Composite (Компоновщик) - использует один класс для представления древовидной структуры.
* Proxy (Заместитель) - заместитель является посредником между двумя другими объектами, 
  который реализует/ограничивает доступ к одному объекту
* Facade (Фасад) - простой интерфейс для клиента, и клиент использует
  интерфейс для взаимодействия с системой.
* Bridge (Мост) - делает конкретные классы независимыми от классов реализации интерфейса.
* Decorator (Декоратор) - добавляет новые функциональные возможности существующего объекта.

###Поведенческие

* Template Method (Шаблонный метод) - определяющий основу алгоритма и позволяющий наследникам 
  переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.
* Mediator (Посредник) - предоставляет класс посредника, который обрабатывает все коммуникации
  между различными классами.
* Chain of Responsibility (Цепочка обязанностей) - позволяет избежать жесткой зависимости 
  отправителя запроса от его получателя, при этом запрос может быть обработан несколькими объектами.
* Observer (Наблюдатель) - позволяет одним объектам следить и реагировать на события, 
  происходящие в других объектах.
* Strategy (Стратегия) - алгоритм стратегии может быть изменен во время выполнения программы.
* Command (Команда) - интерфейс команды объявляет метод для выполнения определенного действия.
* State (Состояние) - объект может изменять свое поведение в зависимости от его состояния.
* Iterator (Итератор) - последовательно осуществляет доступ к элементам объекта коллекции, 
  не зная его основного представления.
